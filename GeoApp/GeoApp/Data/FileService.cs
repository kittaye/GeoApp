using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using PCLStorage;
using System.Threading.Tasks;


namespace GeoApp {
    public class FileService : IDataService {
        // Do NOT change this!
        private const string EMBEDDED_FILENAME = "locations.json";

        // Set this to true in the constructor to delete the current embedded file, remember to set back to false on the next build.
        private bool DEBUG_DELETE_EMBEDDED_FILE;

        // Determines the source json file to read from when replacing the embedded file after a deletion.
        private readonly string EMBEDDED_FILE_SOURCE_PATH;


        /// <summary>
        /// Constructor for FileService. Edit the default parameters here if you want to adjust the initial behaviour of the embedded file.
        /// </summary>
        /// <param name="delete_file">Bool to delete the current embedded file or not</param>
        /// <param name="source_file">Source json file to replace the contents of the embedded file after deletion</param>
        public FileService(bool delete_file = false, string source_file = "GeoApp.locationsAutoGenerated.json") {
            this.DEBUG_DELETE_EMBEDDED_FILE = delete_file;
            this.EMBEDDED_FILE_SOURCE_PATH = source_file;
        }

        /// <summary>
        /// Deletes a current feature by ID, and saves the change by writing to the embedded file.
        /// </summary>
        /// <param name="id">ID of feature to remove</param>
        /// <returns></returns>
        public async Task<bool> DeleteFeatureAsync(int id) {
            Feature featureToDelete = App.FeaturesManager.CurrentFeatures.Find((feature) => (feature.properties.id == id));
            bool deleteSuccessful = App.FeaturesManager.CurrentFeatures.Remove(featureToDelete);

            if (deleteSuccessful) {
                await SaveCurrentFeaturesToEmbeddedFile();
                return true;
            } else {
                Debug.WriteLine($"\n\n:::::::::::::::::::::::FAILED TO DELETE FEATURE OF ID: {id}");
                return false;
            }
        }

        /// <summary>
        /// Returns the most current reading of the embedded file containing a list of features.
        /// </summary>
        /// <returns></returns>
        public Task<List<Feature>> RefreshDataAsync() {
            return Task.Run(async () => {
                IFile featuresFile = await GetEmbeddedFile();

                var rootobject = JsonConvert.DeserializeObject<RootObject>(await featuresFile.ReadAllTextAsync());
                if(rootobject == null) {
                    Debug.WriteLine("\n\n::::::::::::::::::::::DESERIALIZATION FAILED");
                    throw new Exception();
                }

                rootobject.type = "FeatureCollection";

                foreach (var feature in rootobject.features) {
                    // Immediately convert LineStrings to Line for use in the rest of the codebase. 
                    // This will be converted back to LineString before serialization back to json.
                    if(feature.geometry.type == "LineString") {
                        feature.geometry.type = "Line";
                    }

                    // If the date field is missing or invalid, convert it into DateTime.Now.
                    DateTime dummy;
                    if (feature.properties.date == null || DateTime.TryParse(feature.properties.date, out dummy) == false) {
                        Debug.WriteLine($"\n\n::::::::::::::::::::::BAD DATE VALUE: {feature.properties.date}, DEFAULTING TO DateTime.Now");
                        feature.properties.date = DateTime.Now.ToShortDateString();
                    }

                    // Initialise xamarin coordinates list and metadata fields list if it is not already set.
                    feature.properties.xamarincoordinates = new List<Point>();
                    if (feature.properties.metadatafields == null || feature.properties.metadatafields.Count == 0) {
                        feature.properties.metadatafields = new Dictionary<string, object>();
                    }

                    // Determine the icon used for each feature based on it's geometry type.
                    if (feature.geometry.type == "Point") {
                        feature.properties.typeIconPath = "point_icon.png";
                    } else if (feature.geometry.type == "Line") {
                        feature.properties.typeIconPath = "line_icon.png";
                    } else if (feature.geometry.type == "Polygon") {
                        feature.properties.typeIconPath = "area_icon.png";
                    } else {
                        Debug.WriteLine($"\n\n::::::::::::::::::::::::INVALID TYPE: {feature.geometry.type}");
                        throw new Exception();
                    }

                    // Properly deserialize the list of coordinates into an app-use-specific list of Points (XamarinCoordinates).
                    {
                        object[] trueCoords;

                        if (feature.geometry.type == "Point") {
                            trueCoords = feature.geometry.coordinates.ToArray();
                            feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));

                        } else if (feature.geometry.type == "Line") {
                            // Iterates the root coordinates (List<object>),
                            // then casts each element in the list to a Jarray which contain the actual coordinates.
                            for (int i = 0; i < feature.geometry.coordinates.Count; i++) {
                                trueCoords = ((JArray)feature.geometry.coordinates[i]).ToObject<object[]>();
                                feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));
                            }
                        } else if (feature.geometry.type == "Polygon") {
                            // Iterates the root coordinates (List<object>), and casts each element in the list to a Jarray, 
                            // then casts each Jarray's element to another Jarray which contain the actual coordinates.
                            for (int i = 0; i < feature.geometry.coordinates.Count; i++) {
                                for (int j = 0; j < ((JArray)feature.geometry.coordinates[i]).Count; j++) {
                                    trueCoords = ((JArray)(((JArray)feature.geometry.coordinates[i])[j])).ToObject<object[]>();
                                    feature.properties.xamarincoordinates.Add(JsonCoordToXamarinPoint(trueCoords));
                                }
                            }
                        } else {
                            Debug.WriteLine($"\n\n::::::::::::::::::::INVALID TYPE WHEN PARSING POINTS: {feature.geometry.type}");
                            throw new Exception();
                        }
                    }
                }
                return rootobject.features;
            });
        }

        /// <summary>
        /// Converts raw geojson coordinates for a single point into a Point class (xamarin point).
        /// </summary>
        /// <param name="coords">A single point to convert.</param>
        /// <returns></returns>
        private Point JsonCoordToXamarinPoint(object[] coords) {
            double latitude = (double)coords[0];
            double longitude = (double)coords[1];
            double altitude = (coords.Length == 3) ? (double)coords[2] : 0.0;

            Point point = new Point(latitude, longitude, altitude);
            AppConstants.RoundGPSPosition(point);
            return point;
        }

        /// <summary>
        /// Saves a new or edited feature, determined by whether the ID already exists or not.
        /// </summary>
        /// <param name="feature">The feature to save.</param>
        /// <returns></returns>
        public async Task<bool> SaveFeatureAsync(Feature feature)
        {
            // If this is a newly added feature, generate an ID and add it immediately.
            if (feature.properties.id == AppConstants.NEW_ENTRY_ID) {
                feature.properties.id = TryGetUniqueFeatureID(feature.properties.id);
                App.FeaturesManager.CurrentFeatures.Add(feature);
            } else {
                // Otherwise we are saving over an existing feature, so override its contents without changing ID.
                int indexToEdit = -1;
                for (int i = 0; i < App.FeaturesManager.CurrentFeatures.Count; i++) {
                    if (App.FeaturesManager.CurrentFeatures[i].properties.id == feature.properties.id) {
                        indexToEdit = i;
                        break;
                    }
                }

                if (indexToEdit != -1) {
                    App.FeaturesManager.CurrentFeatures[indexToEdit] = feature;
                } else {
                    Debug.WriteLine($"\n\n::::::::::::::::::::::FAILED TO SAVE EDIT FOR FEATURE WITH ID: {feature.properties.id}");
                    return false;
                }
            }

            await SaveCurrentFeaturesToEmbeddedFile();
            return true;
        }

        /// <summary>
        /// If necessary, creates a new ID that is unique to all current features stored.
        /// </summary>
        /// <returns>The original ID if no clashes were found, else a new unique ID.</returns>
        private int TryGetUniqueFeatureID(int currentlyUsedID) {
            int result = currentlyUsedID;
            bool validID = false;

            while (validID == false) {
                validID = true;

                if(result == AppConstants.NEW_ENTRY_ID) {
                    validID = false;
                } else {
                    foreach (var feature in App.FeaturesManager.CurrentFeatures) {
                        if (result == feature.properties.id) {
                            validID = false;
                            break;
                        }
                    }
                }

                if(validID == false) {
                    result = DateTime.Now.GetHashCode();
                }
            }
            return result;
        }

        /// <summary>
        /// Returns the embedded file from the device's storage if it exists, else returns a new embedded file created from a source file.
        /// </summary>
        /// <returns>The embedded file containing current features</returns>
        public async Task<IFile> GetEmbeddedFile() {
            IFolder rootFolder = FileSystem.Current.LocalStorage;
            rootFolder.Path.Replace("/../Library", " ");

            ExistenceCheckResult embeddedFileExists = await rootFolder.CheckExistsAsync(EMBEDDED_FILENAME);

            // If DEBUG bool set to true, will delete the embedded file and create a new one from the source path.
            if (DEBUG_DELETE_EMBEDDED_FILE) {
                DEBUG_DELETE_EMBEDDED_FILE = false;
                if (embeddedFileExists == ExistenceCheckResult.FileExists) {
                    IFile file = await rootFolder.GetFileAsync(EMBEDDED_FILENAME);
                    await file.DeleteAsync();
                    Debug.WriteLine("\n\n:::::::::::::::::::DELETE SUCCESSFUL (Turn off this bool in the next build to re-enable persistent storage)");
                    embeddedFileExists = ExistenceCheckResult.NotFound;
                }
            }

            // Attempt to open the embedded file on the device. 
            // If it exists return it, else create a new embedded file from a json source file.
            if (embeddedFileExists == ExistenceCheckResult.FileExists) {
                return await rootFolder.GetFileAsync(EMBEDDED_FILENAME);
            } else {
                var assembly = IntrospectionExtensions.GetTypeInfo(this.GetType()).Assembly;
                Stream stream = assembly.GetManifestResourceStream(EMBEDDED_FILE_SOURCE_PATH);

                string json;
                using (var reader = new System.IO.StreamReader(stream)) {
                    json = reader.ReadToEnd();
                }

                IFile featuresFile = await rootFolder.CreateFileAsync(EMBEDDED_FILENAME, CreationCollisionOption.ReplaceExisting);
                await featuresFile.WriteAllTextAsync(json);
                return featuresFile;
            }
        }

        /// <summary>
        /// Formats the list of current features into valid geojson, then writes it to the embedded file.
        /// </summary>
        /// <returns></returns>
        private async Task SaveCurrentFeaturesToEmbeddedFile() {
            var objToSave = FormatCurrentFeaturesIntoGeoJSON();

            // Save the rootobject to file.
            var json = JsonConvert.SerializeObject(objToSave);
            IFolder rootFolder = FileSystem.Current.LocalStorage;
            IFile featuresFile = await GetEmbeddedFile();
            await featuresFile.WriteAllTextAsync(json);
        }

        /// <summary>
        /// Imports features from a specified filepath.
        /// </summary>
        /// <param name="path">path to file.</param>
        /// <returns></returns>
        public async Task<bool> ImportFeaturesFromFile(string path) {
            try {
                String text = File.ReadAllText(path);
                await ImportFeaturesAsync(text);
                return true;
            } catch (Exception ex) {
                await HomePage.Instance.DisplayAlert("Invalid File", "An unknown error occured when trying to process this file.", "OK");
                Debug.WriteLine(ex);
                return false;
            }
        }

        /// <summary>
        /// Imports features from the contents of a file.
        /// </summary>
        /// <param name="fileContents">The string of geojson to import from.</param>
        /// <returns></returns>
        public async Task<bool> ImportFeaturesAsync(string fileContents) {
            try {
                var importedRootObject = JsonConvert.DeserializeObject<RootObject>(fileContents);
                if(importedRootObject == null) {
                    Debug.WriteLine($"\n\n:::::::::::::::::DESERIALIZATION FAILED");
                    return false;
                }

                // Loop through all imported features one by one, ensuring there are no ID clashes.
                foreach (var importedFeature in importedRootObject.features) {
                    importedFeature.properties.id = TryGetUniqueFeatureID(importedFeature.properties.id);
                    App.FeaturesManager.CurrentFeatures.Add(importedFeature);
                }

                await SaveCurrentFeaturesToEmbeddedFile();
                return true;
            } catch (Exception ex) {
                await HomePage.Instance.DisplayAlert("Invalid File Contents", "Please make sure your GeoJSON is formatted correctly.", "OK");
                Debug.WriteLine(ex);
                return false;
            }
        }

        /// <summary>
        /// Takes the current list of features and prepare the contents into a valid geoJSON serializable structure.
        /// </summary>
        /// <returns></returns>
        private RootObject FormatCurrentFeaturesIntoGeoJSON() {
            var rootobject = new RootObject();
            rootobject.type = "FeatureCollection";
            rootobject.features = App.FeaturesManager.CurrentFeatures;

            foreach (var feature in rootobject.features) {
                // Convert Lines back into LineStrings for valid geojson.
                if (feature.geometry.type == "Line") {
                    feature.geometry.type = "LineString";
                }
            }
            return rootobject;
        }

        /// <summary>
        /// Exports the current list of features by serializing to geojson.
        /// </summary>
        /// <returns></returns>
        public string ExportFeaturesToJson() {
            try {
                var rootobject = FormatCurrentFeaturesIntoGeoJSON();
                var json = JsonConvert.SerializeObject(rootobject, Formatting.Indented);

                // String cleaning
                if (json.StartsWith("[")) json = json.Substring(1);
                if (json.EndsWith("]")) json = json.TrimEnd(']');
                return json;

            } catch (Exception ex) {
                Debug.WriteLine(ex);
                throw ex;
            }
        }
    }
}
